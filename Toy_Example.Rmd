---
title: "Toy Example"
author: "Sohyeon Kim"
output: 
  github_document:
    pandoc_args: --webtex
header-includes:
  - \usepackage{kotex}
---

```{r warning = FALSE, message = FALSE}
library(tidyverse)
library(ggplot2)
library(splines)
library(Matrix)
library(pander)
library(gridExtra)
library(foreach)
library(doParallel)
library(Rcpp)
library(glmnet)
library(fda)

sourceCpp("functions/add_decomp_function.cpp")
source("https://raw.githubusercontent.com/S0Hye0NKim/add_decomp/master/functions/add_decomp_function.R")
```


# 0. Initial Setting

$$\begin{aligned}Y &\in \mathbb{R}^{n\times g}\\Y &= XB(\tau) + \epsilon(\tau) , \; X\sim N(0, 1)\\ X &\in\mathbb{R}^{n \times (p+1)}, \; \;B(\tau) \in \mathbb{R}^{(p+1)\times g} , \; and \; Q_\tau(\epsilon(\tau)|X) = 0\end{aligned}$$

$$\begin{aligned}\beta_0(\tau) &= \beta_0 + Q_\tau(\epsilon) \\ \epsilon(\tau) &= \epsilon- Q_\tau(\epsilon), \; \epsilon \sim N(0, 0.1^2)\end{aligned}$$

 * n : # of observation. 
 * m : # of group. 
 * p : # of covariate. 
 * r : nonzero entry in true $\Gamma(\tau)$
 * K : # of basis function.
 * b : # of regional quantiel we consider.
 
For toy example, I will use n = 300, p = 50, g = 20.

```{r}
set.seed(1)
n <- 400
m <- 10
p <- 30
b <- 15
num_rank <- 5

sigma_mat <- matrix(nrow = p, ncol = p)
for(j in 1:p) {
  for(k in 1:p) {
    sigma_mat[j, k] <- 0.3^(abs(j-k))
  }
}

X <- matrix(rnorm(n*p, mean = 0, sd = 1), nrow = n)
X <- X %*% expm::sqrtm(sigma_mat) %>%
    cbind(rep(1, n), .)
  
col_ind <- sample(1:m, size = m, replace = FALSE)
row_ind <- sample(1:(p+1), size = m)
sp_mat <- matrix(0, nrow = p+1, ncol = m)
for(i in 1:m) {
   sp_mat[row_ind[i], col_ind[i]] <- rnorm(1, mean = 5, sd = 0.1)
}

LR_mat <- matrix(rnorm((p+1)*m, mean = 1, sd = 3), ncol = m) # make low rank matrix using SVD
SVD <- svd(LR_mat)
D_mat <- diag(SVD$d)
idx <- (num_rank+1):min(m, p)
D_mat[idx, idx] <- 0
LR_mat <- SVD$u %*% D_mat %*% t(SVD$v)

sigma <- runif(n,0.3,0.7)
eps <- MASS::mvrnorm(n = m, mu = rep(0,n), Sigma = diag(sigma^2,n)) %>% t()

Y <- X %*% (LR_mat + sp_mat) + eps
```


$B(\tau)$ = sparse matrix + low rank matrix

# 1. Preliminary
 
### 1-1. Check function

```{r}
check_ft <- function(x, tau) {
  z <- ifelse(x<0, (tau-1)*x, tau*x)
  return(z)
}
```

$$\rho_\tau(x) = (\tau - \mathbb{I}(x<0))x$$

### 1-2. Basis function


```{r}
K <- 10
tau_seq <- seq(from = 0.35, to = 0.65, length.out = b)
tau_seq_real <- tau_seq[tau_seq >= 0.4 & tau_seq <= 0.6]

knots_seq <- seq(min(tau_seq)- 0.02, max(tau_seq) + 0.02, length.out = K)
Phi <- fda::bsplineS(tau_seq, breaks= knots_seq, norder=2, nderiv=0, returnMatrix=FALSE)
```


$$\begin{aligned}\boldsymbol{v}_i^{(\ell)} &= (\boldsymbol{x}_i \otimes \Phi(\tau_{\ell}))^T\\ &=(\Phi(\tau_\ell)^T, x_{i1}\Phi(\tau_\ell)^T, \dots, x_{ip}\Phi(\tau_\ell)^T) \\ &\in \mathbb{R}^{(p+1)K}\end{aligned}$$

### 1-3. New design matrix for regional quantile


```{r}
V <- calc_V(X, Phi)
```




 * Dimension for V : $b \times n \times (p+1)K$

$$\boldsymbol{V}^{(\ell)} = \begin{bmatrix} v_1^{(\ell)} \\v_2^{(\ell)} \\ \vdots \\ v_n^{(\ell)}\end{bmatrix} \in \mathbb{R}^{n\times (p+1)K}$$

### 1-4. Initial value for estimator


$$\boldsymbol{\eta}^{(g)}, \boldsymbol{\theta}^{(g)}, \boldsymbol{w}^{(g)}\in \mathbb{R}^{(p+1)\times K}\\ \boldsymbol{\alpha}^{(g)} \in \mathbb{R}^{p+1} \\ \boldsymbol{e}^{(\ell)(g)}, \boldsymbol{u}^{(\ell)(g)}, \in \mathbb{R}^{n}\\subject\; to \; \boldsymbol{\eta}^{(g)} - \boldsymbol{\theta}^{(g)} = 0, \; and \;\boldsymbol{Y}^{(g)} - \boldsymbol{X}\boldsymbol{\alpha}^{(g)} - \boldsymbol{V}^{(\ell)}\boldsymbol{\eta}^{(g)} - \boldsymbol{e}^{(\ell)(g)} = 0$$


# 2. Algorithm

$$\begin{aligned}\boldsymbol{Y}&=\boldsymbol{XA}+\boldsymbol{X\Gamma}(\tau)\\&=\boldsymbol{Z}+\boldsymbol{V}_{\tau_\ell}\boldsymbol{\Theta}\end{aligned}$$


$$\hat{\Gamma}_{11}(\tau_1)=\cdots=\hat{\Gamma}_{11}(\tau_\ell)=0=\Gamma_{11}(\tau)$$


## 2-1. Initial value

```{r}
lasso_coef <- matrix(nrow = p+1, ncol = m)
for(g in 1:m) {
  cv.lasso <- cv.glmnet(x = X[, -1], y = Y[, g], alpha = 1, type.measure = "mae")
  lasso_model <- glmnet(X[, -1], Y[, g], family = "gaussian", alpha = 1, lambda = cv.lasso$lambda.min)
  lasso_coef[, g] <- c(lasso_model$a0, as.vector(lasso_model$beta))
}


theta_init <- matrix(nrow = (p+1)*K, ncol = m)
for(g in 1:m) {
  for(j in 0:p) {
    theta_init[((j*K)+1):((j+1)*K), g] <- lasso_coef[j+1, g]
  }
}

Y_modified <- Y - X%*%lasso_coef

lin_model <- lm(Y_modified~., data = data.frame(X[, -1]))
alpha_init <- lin_model$coefficients

init_val <- add_decomp_r(delta = 1, lambda_1 = 13, lambda_2 = 80, tol_error = 0.1, max_iter = 10,
                       X = X, Y = Y, V = V, Phi = Phi, 
                     theta_0 = theta_init, alpha_0 = alpha_init, tau_seq = tau_seq, weight = FALSE)

```


```{r}
BIC_func <- function(X, Y, V, Phi, theta_0, alpha_0, tau_seq, tau_seq_real, lamb1_seq, lamb2_seq, 
                     max_iter) {
  m <- ncol(Y)
  p <- ncol(X) - 1
  K <- ncol(V[[1]])/(p+1)
  idx_tau <- tau_seq %in% tau_seq_real
  
  # iteration for lamb1_seq and lamb2_seq
  cores=detectCores()
  cl <- makeCluster(cores[1]-2) #not to overload your computer
  registerDoParallel(cl) # Ready to parallel
  
  simulation <- foreach(lambda_1 = lamb1_seq, .noexport = "add_decomp") %:%
    foreach(lambda_2 = lamb2_seq, .noexport = "add_decomp") %dopar% {
      library(tidyverse)
      library(splines)
      library(Matrix)
      library(Rcpp)
      library(glmnet)
      library(fda)
      sourceCpp("functions/add_decomp_function.cpp")
      
      result <- add_decomp(delta = 1, lambda_1 = lambda_1, lambda_2 = lambda_2, tol_error = 0.001, 
                           max_iter = max_iter, X = X, Y = Y, V = V, Phi = Phi, 
                           theta_0, alpha_0, tau_seq = tau_seq)
      
      result
    }
  stopCluster(cl)
  
  simulation <- lapply(simulation, FUN = function(x) `names<-`(x, value = paste0("lambda_2=", lamb2_seq)))
  names(simulation) <- paste0("lambda_1=", lamb1_seq)
  
  BIC <- list()
  for(i in 1:length(lamb1_seq)) {
    BIC[[i]] <- list()
    for(j in 1:length(lamb2_seq)) {
      result <- simulation[[i]][[j]]
      est_error <- lapply(V[idx_tau], FUN = function(x) (Y - X %*% result$alpha - x %*% result$theta)
                          %>% as.vector())
      check_loss_err <- mapply(FUN = function(x, tau) check_ft(x, tau), x = est_error, 
                               tau = as.list(tau_seq_real), SIMPLIFY = FALSE) %>%
        lapply(FUN = function(x) sum(x)/n) %>% unlist %>% sum
      gamma_tau_hat <- est_gamma(Phi[idx_tau, ], result$theta)
      S_hat <- check_sp_table(true = matrix(0, nrow = (p+1), ncol = m), 
                              est = gamma_tau_hat, table = TRUE, tol = 0.1^5, tau_seq = tau_seq_real) %>%
        .$Est_Positive %>% sum
      BIC[[i]][[j]] <- data.frame(log_Q = log(check_loss_err), 
                                  r_hat = rankMatrix(result$alpha)[1], 
                                  S_hat = S_hat)
    }
  }
  
  BIC_data <- lapply(BIC, FUN = function(x) `names<-`(x, value = lamb2_seq) %>% 
                       bind_rows(.id = "lambda_2")) %>%
    `names<-`(value = lamb1_seq) %>%
    bind_rows(.id = "lambda_1") %>%
    mutate(term = (r_hat * (m + p - r_hat) + K * S_hat)/(2*n*m), 
           BIC_log_sum = log_Q + log(p+m)*term, 
           BIC_log_p = log_Q + log(p)*term, 
           BIC_log_n = log_Q + log(n)*term, 
           BIC_llog_p = log_Q + log(log(p))*term,
           BIC_llog_n = log_Q + log(log(n))*term) %>%
    group_by(lambda_1, lambda_2) %>%
    select_at(vars(starts_with("BIC"))) %>%
    ungroup()
  
  BIC_val_min <- apply(select_at(BIC_data, vars(starts_with("BIC"))), 2, min) %>%
    `names<-`(value = c("log_sum", "log_p", "log_n", "llog_p", "llog_n"))
  
  min_BIC <- filter(BIC_data, BIC_log_sum == BIC_val_min["log_sum"]| BIC_log_p == BIC_val_min["log_p"] |
                      BIC_log_n == BIC_val_min["log_n"] | BIC_llog_p == BIC_val_min["llog_p"] | 
                      BIC_llog_n == BIC_val_min["llog_n"])
  
  output <- list(min_BIC = min_BIC, 
                 BIC_data = BIC_data, 
                 simulation = simulation)
  
  
  return(output)
}
```

```{r}
lamb1_seq <- seq(10, 40, by = 10)
lamb2_seq <- seq(1000, 8000, by = 1000)

BIC_simul <- BIC_func(X, Y, V, Phi, theta_0 = init_val$theta, alpha_0 = init_val$alpha, tau_seq, tau_seq_real, lamb1_seq = lamb1_seq, lamb2_seq = lamb2_seq, max_iter = 50)
```


```{r}
BIC_lamb1 <- BIC_simul$min_BIC$lambda_1
BIC_lamb2 <- BIC_simul$min_BIC$lambda_2


result <- BIC_simul$simulation[[which(lamb1_seq == BIC_lamb1)]][[which(lamb2_seq == BIC_lamb2)]]
```


$\lambda_1, \lambda_2, \delta$ 어떻게?


```{r}
result$iter_error %>% 
  `colnames<-`(value = c("eta", "theta", "alpha", "e", "u", "w")) %>% 
  na.omit() %>%
  data.frame %>%
  mutate(iter = 1:nrow(.)) %>%
  filter(iter > 15) %>% 
  gather(key = "estimator", value = "value", -iter) %>%
  ggplot() +
  geom_line(aes(x = iter, y = value, group = estimator, color = estimator)) +
  facet_wrap(~estimator, scales = "free_y")
```


 * Stopping criteria

$$\begin{aligned}&||\eta^{k+1}-\eta^{k}||_2^2+||\theta^{k+1}-\theta^k||_2^2+||\alpha^{k+1}-\alpha^k||_2^2\\&+||e^{k+1}-e^k||_2^2+||u^{k+1}-u^k||_2^2+||w^{k+1}-w^k||_2^2 \le \epsilon_{tol}\end{aligned}$$

# 3. Evaluation

$\Gamma(\tau)$는 $\tau$에 상관 없이 동일하므로, quantile 상관 없이 $Y\approx\hat{Y}_{\tau_\ell}$ 동일.

```{r}
Y_hat_tau <- lapply(V, FUN = function(x) x %*% result$theta + X %*% result$alpha) %>%
  `names<-`(value = tau_seq)
```

### Low rank matrix

$$\frac{\sigma_1+\cdots+\sigma_5}{\sigma_1+\cdots+\sigma_{20}}\quad\text{where }\sigma_i\text{ is a singular value}$$

```{r}
sing_val <- svd(result$alpha)$d
sum(sing_val[1:5])/sum(sing_val)
rankMatrix(result$alpha)
```
$$\frac{||\hat{A}-A||_F}{||A||_F}$$

```{r}
norm(result$alpha - LR_mat, "F")/norm(LR_mat, "F")
```


### Sparse matrix

$\hat{\gamma}_j^{(g)}(\tau_\ell)=\hat{\theta}_{j}^{(g)T}\phi_s(\tau)$



```{r}
idx_tau <- (tau_seq >= 0.4 & tau_seq <= 0.6)

gamma_tau_hat <- est_gamma(Phi[idx_tau, ], result$theta)
```


### sparsity pattern check

```{r}
data.frame(c("TP", "FP"), c("FN", "TN")) %>% 
  `rownames<-`(value = c("True:non_zero", "True:zero")) %>%
  `colnames<-`(value = c("Est:non_zero", "Est:zero")) %>% pander
```

```{r}
check_sp_table(true = sp_mat, est = gamma_tau_hat, table = TRUE, tol = 0.1^5, tau_seq = tau_seq_real)
```


```{r message = FALSE}
sp_heat <- data.frame(col = rep(1:m, each = (p+1)), 
           row = rep(1:(p+1), m),
           value = as.vector(sp_mat)) %>%
  ggplot(aes(x = col, y = -row, fill = value)) +
  geom_tile(color = "grey") +
  scale_fill_gradient(low = "white", high = "blue") +
  theme_bw() +
  theme(axis.line = element_blank(),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank(), 
    axis.title.x = element_blank(), 
    axis.text.x = element_blank(), 
    axis.ticks.x = element_blank(), 
    axis.title.y = element_blank(), 
    axis.text.y = element_blank(), 
    axis.ticks.y = element_blank()) +
  ggtitle(expression(Gamma~"("~0.5~")")) 

#gamma_heat <- data.frame(col = rep(1:m, each = (p+1)), 
           #row = rep(1:(p+1), m),
           #value = as.vector(gamma_tau_hat[[11]])) %>%
  #mutate(value = ifelse(abs(value) < 0.1^5, 0, value)) %>%
  #ggplot(aes(x = col, y = -row, fill = value)) +
  #geom_tile(color = "grey") +
  #scale_fill_gradient2(low = "red",mid = "white", high = "blue") +
  #theme_bw() +
  #theme(axis.line = element_blank(),
    #panel.grid.major = element_blank(),
    #panel.grid.minor = element_blank(),
    #panel.border = element_blank(),
    #panel.background = element_blank(), 
    #axis.title.x = element_blank(), 
    #axis.text.x = element_blank(), 
    #axis.ticks.x = element_blank(), 
    #axis.title.y = element_blank(), 
    #axis.text.y = element_blank(), 
    #axis.ticks.y = element_blank()) +
  #ggtitle(expression(Gamma~"("~tau[11]~")"))


common_zero_heat <- lapply(gamma_tau_hat, FUN = function(x) data.frame(col = rep(1:m, each = (p+1)),
                                                   row = rep(1:(p+1), m),
                                                   value = as.vector(x))) %>%
  `names<-`(tau_seq_real) %>%
  bind_rows(.id = "tau") %>%
  mutate(nonzero = ifelse(abs(value) < 0.1^5, 0, 1)) %>%
  group_by(col, row) %>%
  summarise(nonzero = mean(nonzero)) %>%
  mutate(nonzero = ifelse(nonzero == 0, 0, 1) %>% as.character) %>%
  ggplot(aes(x = col, y = -row, fill = nonzero)) +
  geom_tile(color = "grey") +
  scale_fill_manual(values = c("white", "black"), name = "entry", label = c("zero", "non-zero")) + 
  theme_bw() +
  theme(axis.line = element_blank(),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank(), 
    axis.title.x = element_blank(), 
    axis.text.x = element_blank(), 
    axis.ticks.x = element_blank(), 
    axis.title.y = element_blank(), 
    axis.text.y = element_blank(), 
    axis.ticks.y = element_blank()) +
  ggtitle(expression(Gamma~"("~tau[l]~")")) 

#grid.arrange(sp_heat, gamma_heat, nrow = 1)
grid.arrange(sp_heat, common_zero_heat, nrow = 1)
```


```{r}
idx_nz_true <- which(sp_mat != 0, arr.ind = TRUE) %>% data.frame()

idx_nz_est <- lapply(gamma_tau_hat, FUN = function(x) which(abs(x) > 0.1^5, arr.ind = TRUE) %>% as_tibble) %>%
    bind_rows (.id = "tau") %>%
    group_by(row, col) %>%
    summarise(zero = n()) 



gamma_tau_hat %>%
  lapply(FUN = function(x) x[idx_nz_true$row, idx_nz_true$col] %>% diag %>%
           data.frame(row = idx_nz_true$row, col = idx_nz_true$col, value = . )) %>%
  `names<-`(value = tau_seq_real) %>%
  bind_rows(.id = "tau") %>%
  unite(col = index, row, col, sep = ",") %>%
  mutate(index = paste0("(", index, ")"), tau = as.numeric(tau)) %>%
  ggplot() +
  geom_line(aes(x = tau, y = value, group = index, color = index), size = 1.2) +
  labs(x = expression(tau[l]), title = expression(gamma~"("~tau[l]~")"~Delta~"=[0.4,0.6]"))
```
```{r}
entry_sp_mat <- data.frame(row = rep(1:(p+1), m), col = rep(1:m, each = p+1), true = sp_mat %>% as.vector ) %>%
  unite(col = index, row, col, sep = ",") %>%
  mutate(index = paste0("(", index, ")"))

gamma_tau_hat %>%
  lapply(FUN = function(x) x[idx_nz_true$row, idx_nz_true$col] %>% diag %>%
           data.frame(row = idx_nz_true$row, col = idx_nz_true$col, est = . )) %>%
  `names<-`(value = tau_seq_real) %>%
  bind_rows(.id = "tau") %>%
  unite(col = index, row, col, sep = ",") %>%
  mutate(index = paste0("(", index, ")"), tau = as.numeric(tau)) %>%
  left_join(entry_sp_mat, by = "index") %>%
  gather(key = "type", value = "value", -tau, -index) %>%
  mutate(group_var = paste0(index, "_", type)) %>%
  ggplot() +
  geom_line(aes(x = tau, y = value, group = group_var, color = index, linetype = type), size = 1.2) +
  labs(x = expression(tau[l]), title = expression(gamma~"("~tau[l]~"), b = 21, "~Delta~"=[0.4,0.6]")) +
  facet_wrap(~index)
```

### Estimation error

$$\begin{aligned}EE &= \sqrt{\int_\Delta\sum_{j=1}^p\sum_{g=1}^m\bigg(\hat{\Gamma}(\tau_\ell)-\Gamma(\tau_\ell)\bigg)^2d\tau/p},\text{   where }\tau_\ell\in[0.4,0.6]\\&=\sqrt{\sum_{g=1}^m\sum_{j=1}^p\int_\Delta\bigg(\hat{\Gamma}(\tau_\ell)-\Gamma(\tau_\ell)\bigg)^2d\tau/p}\end{aligned}$$

```{r}
h <- tau_seq_real[2] - tau_seq_real[1]

EE_mat <-  lapply(gamma_tau_hat[-1], FUN = function(x) (x - sp_mat)*(x - sp_mat) * h) %>%
  Reduce("+", .) 

EE_mat %>% apply(2, mean) %>% sum %>% sqrt

```

### Relative error

$$\begin{aligned}RE&=\frac{\sqrt{\int_\Delta\sum_{j=1}^p\sum_{g=1}^m\bigg(\hat{\Gamma}(\tau_\ell)-\Gamma(\tau_\ell)\bigg)^2d\tau/p}}{\sqrt{\int_\Delta\sum_{j=1}^p\sum_{g=1}^m\bigg(\Gamma(\tau_\ell)\bigg)^2d\tau/p}}\end{aligned}$$

```{r}
RE_denom <- lapply(gamma_tau_hat[-1], FUN = function(x) (x)*(x) * h) %>%
  Reduce("+", .) 

RE <- (EE_mat %>% apply(2, mean) %>% sum %>% sqrt)/(RE_denom %>% apply(2, mean) %>% sum %>% sqrt)
RE
```



### Objective function
$$\begin{aligned}\text{obj.func} =& \sum_{g=1}^m\sum_{\ell=1}^b\sum_{i=1}^n\frac{1}{n}\rho_{\tau_\ell}(Y_i^{(g)}-X\alpha^{(g)}-V^{(\ell)}\theta^{(g)}) \\&+\lambda_1||XA||_*+\lambda_2\sum_{g=1}^m\sum_{j=1}^p||\theta^{(g)}_j||_2\end{aligned}$$

```{r}
est_error <- lapply(V[idx_tau], FUN = function(x) (Y - X %*% result$alpha - x %*% result$theta)
                    %>% as.vector())

check_loss_err <- mapply(FUN = function(x, tau) check_ft(x, tau), x = est_error, 
                           tau = as.list(tau_seq_real), SIMPLIFY = FALSE) %>%
  lapply(FUN = function(x) sum(x)/n) %>% unlist %>% sum

low_rank_penalty <- svd(X %*% result$alpha) %>% .$d %>% sum

sparse_penalty <- 0
for(j in 0:p) {
  for(g in 1:m) {
    theta_j_g <- result$theta[(K*j +1):((j+1)*K), g]
    norm <- theta_j_g^2 %>% sum %>% sqrt
    sparse_penalty <- sparse_penalty + norm
  }
}

check_loss_err + lambda_1*low_rank_penalty + lambda_2 * sparse_penalty
```



### Frobenius norm ratio

$$\frac{||\hat{A}-A||_F}{||A||_F}$$

```{r eval = FALSE}
lamb_1_seq <- seq(from = 0.05, to = 0.3, by = 0.05)
simul_lamb1 <- list()

for(idx in 1:length(lamb_1_seq)) {
  simul_lamb1[[idx]] <- add_decomp(delta = 0.5, lambda_1 = lamb_1_seq[idx], lambda_2 = 2.5,
                                   tol_error = 0.1, max_iter = 50)
  if((idx %% 2) == 1) print(paste0("iter = ", idx))
}
```

```{r eval = FALSE}
alpha_hat <- simul_lamb1 %>% lapply(FUN = function(x) x$alpha)

alpha_hat %>%
  lapply(FUN = function(x) norm(LR_mat - x, type = "F")/norm(LR_mat, type = "F") %>% data.frame(value = .)) %>%
  `names<-`(value = lamb_1_seq) %>%
  bind_rows(.id = "lambda_1") %>%
  ggplot() +
  geom_line(aes(x = as.numeric(lambda_1), y = value)) +
  labs(title = expression("Frobenius norm ratio when "~delta~"=0.1, "~lambda[2]~"=0.5, "~lambda[1]~"in (0.05,0.3)"), 
       x = expression(lambda[1]))
```



```{r eval = FALSE}
lapply(alpha_hat, FUN = function(x) svd(x) %>% .$d) %>%
  lapply(FUN = function(x) data.frame(ratio = (sum(x[1:num_rank])/sum(x)), rank = sum(abs(x) > 0.1^5))) %>%
  `names<-`(value = lamb_1_seq) %>%
  bind_rows(.id = "lambda1")
```



### ROC curve


```{r}
lamb2_seq <- c(10, 50, 100, seq(500, 4000, by = 100), 6000, 8000, 10000)

simul <- BIC_func(X, Y, V, Phi, theta_0 = init_val$theta, alpha_0 = init_val$alpha, tau_seq, tau_seq_real, lamb1_seq = 10, lamb2_seq = lamb2_seq, max_iter = 50)

simulation <- simul$simulation[[1]]
```


```{r eval = FALSE}
theta_hat <- simulation %>%
  lapply(FUN = function(x) x$theta)

gamma_tau_hat <- list()
for(idx in 1:length(lamb2_seq)) {
  gamma_tau_hat[[idx]] <- est_gamma(Phi[idx_tau, ], theta_hat[[idx]])
}

ROC_table <- list()
for(idx in 1:length(lamb2_seq)) {
  ROC_table[[idx]] <- check_sp_table(true = sp_mat, est = gamma_tau_hat[[idx]], 
                                     tau_seq = tau_seq_real) 
} 

ROC_table %>%
  `names<-`(value = lamb2_seq) %>%
  bind_rows(.id = "lamb_2") %>%
  arrange(FPR, TPR) %>%
  ggplot() +
  geom_line(aes(x = FPR, y = TPR)) +
  geom_point(aes(x = FPR, y = TPR)) +
  geom_abline(intercept = 0, slope = 1) +
  coord_fixed(ratio = 1) +
  ggtitle(label = expression(delta ~ " =1, "~lambda[1] ~ "=10, "~lambda[2] ~ "in (10, 10000), max_iter = 50")) +
  scale_y_continuous(limits = c(0, 1)) +
  scale_x_continuous(limits = c(0, 1))
  
```



```{r}
alpha_hat <- lapply(simul, FUN = function(x) x$alpha) 

lapply(alpha_hat, FUN = function(x) data.frame(FR_ratio = norm(x - LR_mat, "F")/norm(LR_mat, "F"))) %>%
  `names<-`(value = lamb_2_seq) %>%
  bind_rows(.id = "lambda_2") %>%
  mutate(lambda_2 = as.numeric(lambda_2)) %>%
  ggplot() +
  geom_line(aes(x = lambda_2, y = FR_ratio)) +
  ggtitle(label = expression(delta ~ " =0.1, "~lambda[1] ~ "=0.2, "~lambda[2] ~ "in (0.1, 2), max_iter = 50"))+
  coord_fixed(ratio = 2) 
```








