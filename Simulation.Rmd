---
title: "Simulation"
author: "Sohyeon Kim"
output: 
  github_document:
    pandoc_args: --webtex
header-includes:
  - \usepackage{kotex}
---


```{r warning = FALSE, message = FALSE}
library(tidyverse)
library(ggplot2)
library(splines)
library(Matrix)
library(pander)
library(gridExtra)
library(foreach)
library(doParallel)
library(Rcpp)
library(glmnet)
library(fda)

sourceCpp("functions/add_decomp_function.cpp")
source("https://raw.githubusercontent.com/S0Hye0NKim/add_decomp/master/functions/add_decomp_function.R")
```


# 0. Initial Setting


$$\tilde{\textbf{x}}_i\overset{i.i.d}{\sim}N_p(0,\Sigma)\text{ with }\Sigma_{jk}=0.3^{|j-k|}$$

$$\epsilon_i^{(g)}\sim N(0, \sigma_i^{(g)2})\text{ where }\sigma_i\overset{i.i.d}{\sim}U(0.3, 0.7)$$


```{r}
set.seed(0)
n <- 400
m <- 10
p <- 30
b <- 21
num_rank <- 5
simul_times <- 5

sigma_mat <- matrix(nrow = p, ncol = p)
for(j in 1:p) {
  for(k in 1:p) {
    sigma_mat[j, k] <- 0.3^(abs(j-k))
  }
}

X_list <- list()
LR_mat_list <- list()
sp_mat_list <- list()
eps_list <- list()

for(simul in 1:simul_times) {
  X <- matrix(rnorm(n*p, mean = 0, sd = 1), nrow = n)
  X_list[[simul]] <- X %*% expm::sqrtm(sigma_mat) %>%
    cbind(rep(1, n), .)
  
  col_ind <- sample(1:m, size = m, replace = FALSE)
  row_ind <- sample(1:(p+1), size = m)
  sp_mat_list[[simul]] <- matrix(0, nrow = p+1, ncol = m)
  for(i in 1:m) {
    sp_mat_list[[simul]][row_ind[i], col_ind[i]] <- rnorm(1, mean = 5, sd = 0.1)
  }
  
  LR_mat <- matrix(rnorm((p+1)*m, mean = 1, sd = 0.1), ncol = m) # make low rank matrix using SVD
  SVD <- svd(LR_mat)
  D_mat <- diag(SVD$d)
  idx <- (num_rank+1):m
  D_mat[idx, idx] <- 0
  LR_mat_list[[simul]] <- SVD$u %*% D_mat %*% t(SVD$v)
  
  sigma <- runif(n,0.3,0.7)
  eps_list[[simul]] <- mvrnorm(n = m, mu = rep(0,n), Sigma = diag(sigma^2,n)) %>% t()
}

Y_list <- mapply(FUN = function(X, LR, SP, eps) X %*% (LR + SP) + eps, 
                 X_list, LR_mat_list, sp_mat_list, eps_list, SIMPLIFY = FALSE)



```

# 1. Basis Function.

```{r}
K <- 10
tau_seq <- seq(from = 0.4, to = 0.6, length.out = b)

knots_seq <- seq(min(tau_seq) - 0.02, max(tau_seq) + 0.02, length.out = K)
Phi <- fda::bsplineS(tau_seq, breaks= knots_seq, norder=2, nderiv=0, returnMatrix=FALSE)

V_list <- list()
for(simul in 1:simul_times) {
  V_list[[simul]] <- calc_V(X_list[[simul]], Phi)
}
```


# 2. algorithm


```{r}
add_decomp_r <- function(delta, lambda_1, lambda_2, tol_error, max_iter, X, Y, V, Phi, theta_0, alpha_0) {
  # delta = step size
  # lambda_1 = low rank penalty
  # lambda_2 = sparse penalty
  
  # initial value
  eta_old <- theta_0
  theta_old <- eta_old
  alpha_old <- alpha_0
  Z_old <- X %*% alpha_old
  e_old <- list()
  for(l in 1:b) {e_old[[l]] <- Y - Z_old - V[[l]] %*% eta_old}
  u_old <- list()
  for(l in 1:b) {u_old[[l]] <- matrix(0, nrow = n, ncol = m)}
  w_old <- matrix(0, nrow = (p+1)*K, ncol = m)
  
  iter_error <- matrix(ncol = 6, nrow = max_iter) %>%
    `colnames<-`(value = c("eta", "theta", "alpha", "e", "u", "w"))
  
  sum_V <- Reduce("+", V)
  VV_prod <- lapply(V, FUN = function(x) t(x) %*% x)   # V^TV
  sum_VV <- Reduce("+", VV_prod)
  
  for(iter in 1:max_iter) {
    # Process for eta
    eta_new <- matrix(nrow = (p+1)*K, ncol = m)
    Vu_prod <- mapply(function(x,y) t(x) %*% y, V, u_old, SIMPLIFY = FALSE)
    Ve_prod <- mapply(function(x,y) t(x) %*% y, V, e_old, SIMPLIFY = FALSE)
    eta_new <- (solve(sum_VV+diag(1, (p+1)*K))/delta) %*% (w_old + delta * theta_old + Reduce("+", Vu_prod)
                                                           + delta * t(sum_V) %*% (Y - Z_old)
                                                           - delta * Reduce("+", Ve_prod))
    
    # Process for theta
    theta_new <- matrix(nrow = (p+1)*K, ncol = m)
    for (g in 1:m) {
      for(j in 1:(p+1)) {
        eta_j_g <- eta_new[(K*(j-1) +1):(j*K), g]
        w_j_g <- w_old[(K*(j-1) +1):(j*K), g]
        r_j_g <- eta_j_g - (w_j_g/delta)
        norm <- (r_j_g^2) %>% sum %>% sqrt
        value <- 1 - (lambda_2/(delta *norm))
        if(value >= 0) {
          theta_new[(K*(j-1) +1):(j*K), g] <- value * r_j_g
        } else {theta_new[(K*(j-1) +1):(j*K), g] <- 0}
      }
    }
    
    # Process for Z=XA
    Y_list <- list()
    for(i in 1:l) {Y_list[[i]] <- Y}
    VH_list <- lapply(V, FUN = function(x) x %*% eta_new)
    obj_list <- mapply(function(Y, VH, E, U) Y - VH - E - U/delta, Y_list, VH_list, e_old, u_old, SIMPLIFY = FALSE)
    obj <- Reduce("+", obj_list)/b 
    SVD <- svd(obj)
    new_singular <- sapply(SVD$d - lambda_1/(delta*b), FUN = function(x) max(x, 0))
    Z_new <- SVD$u %*% diag(new_singular) %*% t(SVD$v)
    alpha_new <- solve(t(X) %*% X) %*% t(X) %*% Z_new
    
    # Process for e
    e_new <- list()
    for(l in 1:b){
      e_new[[l]] <- matrix(nrow = n, ncol = m)
      for(g in 1:m) {
        error <- Y[, g] - Z_new[, g] - V[[l]] %*% eta_new[, g]   #error = Y - XA - VH
        value <- error + u_old[[l]][, g]/delta
        e_new[[l]][, g] <- case_when(value > tau_seq[l]/(n*delta) ~ value - tau_seq[l]/(n*delta), 
                                     value < (tau_seq[l]-1)/(n*delta) ~ value - (tau_seq[l]-1)/(n*delta), 
                                     value >=(tau_seq[l]-1)/(n*delta) & value <= tau_seq[l]/(n*delta) ~ 0)
      }
    }
    
    # Process for multiplier u
    u_new <- list()
    for(l in 1:b) {
      u_new[[l]] <- u_old[[l]] + delta * (Y - Z_new - V[[l]] %*% eta_new - e_new[[l]])
    }
    
    # Process for multiplier w
    w_new <- w_old + delta * (theta_new - eta_new)
    
    # Update iteration error
    iter_error[iter, "eta"] <- Matrix::norm(eta_old - eta_new, type = "F")
    iter_error[iter, "theta"] <- Matrix::norm(theta_old - theta_new, type = "F")
    iter_error[iter, "alpha"] <- Matrix::norm(alpha_old - alpha_new, type = "F")
    e_diff <- mapply(FUN = function(old, new) old - new, e_old, e_new, SIMPLIFY = FALSE)  # sum of frobenius norm
    iter_error[iter, "e"] <- lapply(e_diff, FUN = function(x) Matrix::norm(x, type = "F")) %>% Reduce("+", .)
    u_diff <- mapply(FUN = function(old, new) old - new, u_old, u_new, SIMPLIFY = FALSE)
    iter_error[iter, "u"] <- lapply(u_diff, FUN = function(x) Matrix::norm(x, type = "F")) %>% Reduce("+", .)
    iter_error[iter, "w"] <- Matrix::norm(w_old - w_new, type = "F")
    
    if(sum(iter_error[iter, ]) < tol_error) break
    
    eta_old <- eta_new
    theta_old <- theta_new
    Z_old <- Z_new
    alpha_old <- alpha_new
    e_old <- e_new
    u_old <- u_new
    w_old <- w_new
  }
  
  return(list(eta = eta_new, 
              theta = theta_new, 
              alpha = alpha_new, 
              e = e_new, 
              u = u_new, 
              w = w_new, 
              iter_error = iter_error))
}
```



```{r}
cores=detectCores()
cl <- makeCluster(cores[1]-2) #not to overload your computer
registerDoParallel(cl) # Ready to parallel

result <- foreach(simul = 1:simul_times) %dopar% {
  library(tidyverse)
  library(splines)
  library(Matrix)
  library(Rcpp)
  library(glmnet)
  library(fda)
  
  tau_seq <- seq(from = 0.4, to = 0.6, length.out = b)
  lasso_coef <- matrix(nrow = p+1, ncol = m)
  for(g in 1:m) {
    cv.lasso <- cv.glmnet(x = X_list[[simul]][, -1], y = Y_list[[simul]][, g], 
                          alpha = 1, type.measure = "mae")
    lasso_model <- glmnet(X_list[[simul]][, -1], Y_list[[simul]][, g], 
                          family = "gaussian", alpha = 1, lambda = cv.lasso$lambda.min)
    lasso_coef[, g] <- c(lasso_model$a0, as.vector(lasso_model$beta))
  }
  
  theta_init <- matrix(nrow = (p+1)*K, ncol = m)
  for(g in 1:m) {
    for(j in 0:p) {
      theta_init[((j*K)+1):((j+1)*K), g] <- lasso_coef[j+1, g]
    }
  }
  
  Y_modified <- Y_list[[simul]] - X_list[[simul]]%*%lasso_coef
  lin_model <- lm(Y_modified~., data = data.frame(X_list[[simul]][, -1]))
  alpha_init <- lin_model$coefficients
  
  simulation <- add_decomp_r(delta = 1, lambda_1 = 4, lambda_2 = 20, tol_error = 0.1,max_iter = 300,
                       X = X_list[[simul]], Y = Y_list[[simul]], V = V_list[[simul]], Phi = Phi, 
                     theta_0 = theta_init, alpha_0 = alpha_init)
  simulation
  
}



stopCluster(cl)
```



































