---
title: "Simulation"
author: "Sohyeon Kim"
output: 
  github_document:
    pandoc_args: --webtex
header-includes:
  - \usepackage{kotex}
---


```{r warning = FALSE, message = FALSE}
library(tidyverse)
library(ggplot2)
library(splines)
library(Matrix)
library(pander)
library(gridExtra)
library(foreach)
library(doParallel)
library(Rcpp)
library(glmnet)
library(fda)

sourceCpp("functions/add_decomp_function.cpp")
source("https://raw.githubusercontent.com/S0Hye0NKim/add_decomp/master/functions/add_decomp_function.R")
```



$$\tilde{\textbf{x}}_i\overset{i.i.d}{\sim}N_p(0,\Sigma)\text{ with }\Sigma_{jk}=0.3^{|j-k|}$$

# Case 1. 


$$\epsilon_i^{(g)}(\tau)\sim N(0, \sigma_i^{(g)2})\text{ where }\sigma_i\overset{i.i.d}{\sim}U(0.3, 0.7)$$

## 0. Initial Setting


```{r}
set.seed(0)
n <- 400
m <- 10
p <- 30
b <- 31
num_rank <- 5
simul_times <- 100

sigma_mat <- matrix(nrow = p, ncol = p)
for(j in 1:p) {
  for(k in 1:p) {
    sigma_mat[j, k] <- 0.3^(abs(j-k))
  }
}

X_list <- list()
LR_mat_list <- list()
sp_mat_list <- list()
eps_list <- list()

for(simul in 1:simul_times) {
  X <- matrix(rnorm(n*p, mean = 0, sd = 1), nrow = n)
  X_list[[simul]] <- X %*% expm::sqrtm(sigma_mat) %>%
    cbind(rep(1, n), .)
  
  col_ind <- sample(1:m, size = m, replace = FALSE)
  row_ind <- sample(1:(p+1), size = m)
  sp_mat_list[[simul]] <- matrix(0, nrow = p+1, ncol = m)
  for(i in 1:m) {
    sp_mat_list[[simul]][row_ind[i], col_ind[i]] <- rnorm(1, mean = 5, sd = 0.1)
  }
  
  LR_mat <- matrix(rnorm((p+1)*m, mean = 1, sd = 0.1), ncol = m) # make low rank matrix using SVD
  SVD <- svd(LR_mat)
  D_mat <- diag(SVD$d)
  idx <- (num_rank+1):m
  D_mat[idx, idx] <- 0
  LR_mat_list[[simul]] <- SVD$u %*% D_mat %*% t(SVD$v)
  
  sigma <- runif(n,0.3,0.7)
  eps_list[[simul]] <- MASS::mvrnorm(n = m, mu = rep(0,n), Sigma = diag(sigma^2,n)) %>% t()
}

Y_list <- mapply(FUN = function(X, LR, SP, eps) X %*% (LR + SP) + eps, 
                 X_list, LR_mat_list, sp_mat_list, eps_list, SIMPLIFY = FALSE)



```


---

# Case 2. 

$$\epsilon_i^{(g)}(\tau)\sim\Phi(\tilde{x}_{i3})t_3$$


## 0. Initial Setting

```{r}
set.seed(0)
n <- 400
m <- 10
p <- 30
b <- 21
num_rank <- 5
simul_times <- 100

sigma_mat <- matrix(nrow = p, ncol = p)
for(j in 1:p) {
  for(k in 1:p) {
    sigma_mat[j, k] <- 0.3^(abs(j-k))
  }
}

X_list <- list()
LR_mat_list <- list()
sp_mat_list <- list()
eps_list <- list()

for(simul in 1:simul_times) {
  X <- matrix(rnorm(n*p, mean = 0, sd = 1), nrow = n)
  X_list[[simul]] <- X %*% expm::sqrtm(sigma_mat) %>%
    cbind(rep(1, n), .)
  
  col_ind <- sample(1:m, size = m, replace = FALSE)
  row_ind <- sample(1:(p+1), size = m)
  sp_mat_list[[simul]] <- matrix(0, nrow = p+1, ncol = m)
  for(i in 1:m) {
    sp_mat_list[[simul]][row_ind[i], col_ind[i]] <- rnorm(1, mean = 5, sd = 0.1)
  }
  
  LR_mat <- matrix(rnorm((p+1)*m, mean = 1, sd = 0.1), ncol = m) # make low rank matrix using SVD
  SVD <- svd(LR_mat)
  D_mat <- diag(SVD$d)
  idx <- (num_rank+1):m
  D_mat[idx, idx] <- 0
  LR_mat_list[[simul]] <- SVD$u %*% D_mat %*% t(SVD$v)
  
  eps_list[[simul]] <- matrix(nrow = n, ncol = m)
  for(i in 1:n) {
    for(j in 1:m) {
      x_i3 <- X_list[[simul]][i, 3]
      t_3 <- rt(1, df = 3)
      eps_list[[simul]][i, j] <- pnorm(x_i3)*t_3
    }
  }
}

Y_list <- mapply(FUN = function(X, LR, SP, eps) X %*% (LR + SP) + eps, 
                 X_list, LR_mat_list, sp_mat_list, eps_list, SIMPLIFY = FALSE)
```

---

# Case 3. 

$$\epsilon_i^{(g)}(\tau)\sim\text{Laplace}(0, \sigma_i^{(g)}),\text{ where }\sigma_i^{(g)}\overset{i.i.d}{\sim}U(0.4, 0.7)$$


## 0. Initial Setting


```{r warning = FALSE}
set.seed(0)
n <- 400
m <- 10
p <- 30
b <- 21
num_rank <- 5
simul_times <- 100

sigma_mat <- matrix(nrow = p, ncol = p)
for(j in 1:p) {
  for(k in 1:p) {
    sigma_mat[j, k] <- 0.3^(abs(j-k))
  }
}

X_list <- list()
LR_mat_list <- list()
sp_mat_list <- list()
eps_list <- list()

for(simul in 1:simul_times) {
  X <- matrix(rnorm(n*p, mean = 0, sd = 1), nrow = n)
  X_list[[simul]] <- X %*% expm::sqrtm(sigma_mat) %>%
    cbind(rep(1, n), .)
  
  col_ind <- sample(1:m, size = m, replace = FALSE)
  row_ind <- sample(1:(p+1), size = m)
  sp_mat_list[[simul]] <- matrix(0, nrow = p+1, ncol = m)
  for(i in 1:m) {
    sp_mat_list[[simul]][row_ind[i], col_ind[i]] <- rnorm(1, mean = 5, sd = 0.1)
  }
  
  LR_mat <- matrix(rnorm((p+1)*m, mean = 1, sd = 0.1), ncol = m) # make low rank matrix using SVD
  SVD <- svd(LR_mat)
  D_mat <- diag(SVD$d)
  idx <- (num_rank+1):m
  D_mat[idx, idx] <- 0
  LR_mat_list[[simul]] <- SVD$u %*% D_mat %*% t(SVD$v)
  
  eps_list[[simul]] <- matrix(nrow = n, ncol = m)
  for(i in 1:n) {
    for(j in 1:m) {
      sigma <- runif(1, 0.4, 0.7)
      eps_list[[simul]][i, j] <- LaplacesDemon::rlaplace(1, location = 0, scale = sigma)
    }
  }
}

Y_list <- mapply(FUN = function(X, LR, SP, eps) X %*% (LR + SP) + eps, 
                 X_list, LR_mat_list, sp_mat_list, eps_list, SIMPLIFY = FALSE)



```

---

# 1. Basis Function.

```{r}
K <- 10
tau_seq <- seq(from = 0.35, to = 0.65, length.out = b)
tau_seq_real <- tau_seq[tau_seq > 0.39 & tau_seq < 0.61]

knots_seq <- seq(min(tau_seq)- 0.02, max(tau_seq) + 0.02, length.out = K)
Phi <- fda::bsplineS(tau_seq, breaks= knots_seq, norder=2, nderiv=0, returnMatrix=FALSE)

V_list <- list()
for(simul in 1:simul_times) {
  V_list[[simul]] <- calc_V(X_list[[simul]], Phi)
}
```


# 2. Simulation

```{r}
start <- Sys.time()
cores=detectCores()
cl <- makeCluster(cores[1]-2) #not to overload your computer
registerDoParallel(cl) # Ready to parallel

simulation <- foreach(simul = 1:simul_times, .noexport = "add_decomp") %dopar% {
  library(tidyverse)
  library(splines)
  library(Matrix)
  library(Rcpp)
  library(glmnet)
  library(fda)
  sourceCpp("functions/add_decomp_function.cpp")
  
  tau_seq <- seq(from = 0.35, to = 0.65, length.out = b)
  lasso_coef <- matrix(nrow = p+1, ncol = m)
  X <- X_list[[simul]]
  Y <- Y_list[[simul]]
  V <- V_list[[simul]]
  for(g in 1:m) {
    cv.lasso <- cv.glmnet(x = X[, -1], y = Y[, g], 
                          alpha = 1, type.measure = "mae")
    lasso_model <- glmnet(X[, -1], Y[, g], 
                          family = "gaussian", alpha = 1, lambda = cv.lasso$lambda.min)
    lasso_coef[, g] <- c(lasso_model$a0, as.vector(lasso_model$beta))
  }
  
  theta_init <- matrix(nrow = (p+1)*K, ncol = m)
  for(g in 1:m) {
    for(j in 0:p) {
      theta_init[((j*K)+1):((j+1)*K), g] <- lasso_coef[j+1, g]
    }
  }
  
  Y_modified <- Y - X%*%lasso_coef
  lin_model <- lm(Y_modified~., data = data.frame(X[, -1]))
  alpha_init <- lin_model$coefficients

  result <- add_decomp(delta = 1, lambda_1 = 8, lambda_2 = 40, tol_error = 0.1, max_iter = 300,
                       X = X, Y = Y, V = V, Phi = Phi, 
                     theta_0 = theta_init, alpha_0 = alpha_init, tau_seq = tau_seq)
  result
  
}



stopCluster(cl)
end <- Sys.time()
```



```{r}
for(simul in 1:(cores[1]-2)) {
  tau_seq <- seq(from = 0.35, to = 0.65, length.out = b)
  lasso_coef <- matrix(nrow = p+1, ncol = m)
  X <- X_list[[simul]]
  Y <- Y_list[[simul]]
  V <- V_list[[simul]]
  for(g in 1:m) {
    cv.lasso <- cv.glmnet(x = X[, -1], y = Y[, g], 
                          alpha = 1, type.measure = "mae")
    lasso_model <- glmnet(X[, -1], Y[, g], 
                          family = "gaussian", alpha = 1, lambda = cv.lasso$lambda.min)
    lasso_coef[, g] <- c(lasso_model$a0, as.vector(lasso_model$beta))
  }
  
  theta_init <- matrix(nrow = (p+1)*K, ncol = m)
  for(g in 1:m) {
    for(j in 0:p) {
      theta_init[((j*K)+1):((j+1)*K), g] <- lasso_coef[j+1, g]
    }
  }
  
  Y_modified <- Y - X%*%lasso_coef
  lin_model <- lm(Y_modified~., data = data.frame(X[, -1]))
  alpha_init <- lin_model$coefficients

  result <- add_decomp(delta = 1, lambda_1 = 8, lambda_2 = 40, tol_error = 0.1, max_iter = 300,
                       X = X, Y = Y, V = V, Phi = Phi, 
                     theta_0 = theta_init, alpha_0 = alpha_init, tau_seq = tau_seq)
  simulation[[simul]] <- result
}
```


# 3. Evaluation.


## 3-1. Low rank matrix

```{r}
alpha_list <- lapply(simulation, FUN = function(x) x$alpha)

sapply(alpha_list, rankMatrix) %>% mean
```

```{r}
lapply(alpha_list, FUN= function(x) svd(x) %>% .$d) %>%
  sapply(FUN = function(x) sum(x[1:5])/sum(x)) %>% mean
```

## 3-2. Sparse matrix

```{r}
theta_list <- lapply(simulation, FUN = function(x) x$theta)

idx_tau <- (tau_seq > 0.39 & tau_seq <= 0.61)
gamma_list <- lapply(theta_list, FUN = function(x) est_gamma(Phi[idx_tau, ], theta = x))
```


```{r message=FALSE}
sp_table <- list()
for(simul in 1:simul_times) {
  sp_table[[simul]] <- check_sp_table(true = sp_mat_list[[simul]], est = gamma_list[[simul]], 
                                      table = FALSE, tau_seq = tau_seq_real)
}


sp_table %>%
  bind_rows() %>%
  mutate(TP = TPR, TN = 1-FPR) %>%
  dplyr::select(TP, TN) %>%
  summarise(TP_mean = mean(TP), TP_sd = sd(TP), TN_mean = mean(TN), TN_sd = sd(TN))

```


## 3-3. Estimation Error


$$\begin{aligned}EE &= \sqrt{\int_\Delta\sum_{j=1}^p\sum_{g=1}^m\bigg(\hat{\Gamma}(\tau_\ell)-\Gamma(\tau_\ell)\bigg)^2d\tau/p},\text{   where }\tau_\ell\in[0.4,0.6]\\&=\sqrt{\sum_{g=1}^m\sum_{j=1}^p\int_\Delta\bigg(\hat{\Gamma}(\tau_\ell)-\Gamma(\tau_\ell)\bigg)^2d\tau/p}\end{aligned}$$


```{r}
h <- tau_seq_real[2] - tau_seq_real[1]

EE <- vector(mode = "numeric", length = simul_times)
for(simul in 1:simul_times) {
  sp_mat <- sp_mat_list[[simul]]
  EE_mat <- lapply(gamma_list[[simul]][-1], FUN = function(x) (x - sp_mat)*(x-sp_mat) * h) %>%
    Reduce("+", .)
  EE[simul] <- EE_mat %>% apply(2, mean) %>% sum %>% sqrt
}

c(mean(EE), sd(EE))
```




# Solution Path

## 1. Data Generation

```{r}
set.seed(0)
n <- 400
m <- 10
p <- 30
b <- 21
num_rank <- 5

X <- matrix(rnorm(n*p, mean = 0, sd = 1), nrow = n) %>% cbind(1, .)   #add intercept term in X

col_ind <- sample(1:m, size = m, replace = FALSE)
row_ind <- sample(1:(p+1), size = m)
sp_mat <- matrix(0, nrow = p+1, ncol = m)
for(i in 1:m) {
  sp_mat[row_ind[i], col_ind[i]] <- rnorm(1, mean = 5, sd = 0.1)
}
num_zero <- which(sp_mat==0, arr.ind = TRUE) %>% nrow
num_nz <- (p+1)*m - num_zero

LR_mat <- matrix(rnorm((p+1)*m, mean = 1, sd = 0.1), ncol = m) # make low rank matrix using SVD
SVD <- svd(LR_mat)
D_mat <- diag(SVD$d)
idx <- (num_rank+1):m
D_mat[idx, idx] <- 0
LR_mat <- SVD$u %*% D_mat %*% t(SVD$v)          

true_B <- sp_mat + LR_mat            # B(tau) = sparse matrix + low rank matrix

eps <- matrix(rnorm(n*m, mean = 0, sd = 0.1), nrow = n)

Y <- X%*%true_B + eps
```

```{r}
K <- 10
tau_seq <- seq(from = 0.4, to = 0.6, length.out = b)

knots_seq <- seq(min(tau_seq) - 0.02, max(tau_seq) + 0.02, length.out = K)
Phi <- fda::bsplineS(tau_seq, breaks= knots_seq, norder=2, nderiv=0, returnMatrix=FALSE)

V <- calc_V(X, Phi)
```

## 2. Low rank

```{r}
cores=detectCores()
cl <- makeCluster(cores[1]-2) #not to overload your computer
registerDoParallel(cl) # Ready to parallel
lamb1_seq <- c(1:10, 15, 20, 30, 35)

simulation <- foreach(lambda_1 = lamb1_seq) %dopar% {
  library(tidyverse)
  library(splines)
  library(Matrix)
  library(Rcpp)
  library(glmnet)
  library(fda)
  
  tau_seq <- seq(from = 0.4, to = 0.6, length.out = b)
  lasso_coef <- matrix(nrow = p+1, ncol = m)
  for(g in 1:m) {
    cv.lasso <- cv.glmnet(x = X[, -1], y = Y[, g], 
                          alpha = 1, type.measure = "mae")
    lasso_model <- glmnet(X[, -1], Y[, g], 
                          family = "gaussian", alpha = 1, lambda = cv.lasso$lambda.min)
    lasso_coef[, g] <- c(lasso_model$a0, as.vector(lasso_model$beta))
  }
  
  theta_init <- matrix(nrow = (p+1)*K, ncol = m)
  for(g in 1:m) {
    for(j in 0:p) {
      theta_init[((j*K)+1):((j+1)*K), g] <- lasso_coef[j+1, g]
    }
  }
  
  Y_modified <- Y - X%*%lasso_coef
  lin_model <- lm(Y_modified~., data = data.frame(X[, -1]))
  alpha_init <- lin_model$coefficients
  
  result <- add_decomp_r(delta = 1, lambda_1 = lambda_1, lambda_2 = 20, tol_error = 0.1,max_iter = 300,
                       X = X, Y = Y, V = V, Phi = Phi, 
                     theta_0 = theta_init, alpha_0 = alpha_init)
  result
}



stopCluster(cl)
```



```{r}
rank <- simulation %>% sapply(FUN = function(x) x$alpha %>% rankMatrix %>% .[1])

data.frame(lambda_1 = lamb1_seq, rank = rank) %>%
  ggplot() +
  geom_line(aes(x = lambda_1, y = rank)) +
  labs(title = "Solution path for low rank matrix", 
       x = expression(lambda[1]))
```

## 3. Sparse matrix

```{r}
cores=detectCores()
cl <- makeCluster(cores[1]-2) #not to overload your computer
registerDoParallel(cl) # Ready to parallel
lamb2_seq <- c(seq(5, 60, by = 5), 70, 80, 90, 100)

simulation <- foreach(lambda_2 = lamb2_seq) %dopar% {
  library(tidyverse)
  library(splines)
  library(Matrix)
  library(Rcpp)
  library(glmnet)
  library(fda)
  
  tau_seq <- seq(from = 0.4, to = 0.6, length.out = b)
  lasso_coef <- matrix(nrow = p+1, ncol = m)
  for(g in 1:m) {
    cv.lasso <- cv.glmnet(x = X[, -1], y = Y[, g], 
                          alpha = 1, type.measure = "mae")
    lasso_model <- glmnet(X[, -1], Y[, g], 
                          family = "gaussian", alpha = 1, lambda = cv.lasso$lambda.min)
    lasso_coef[, g] <- c(lasso_model$a0, as.vector(lasso_model$beta))
  }
  
  theta_init <- matrix(nrow = (p+1)*K, ncol = m)
  for(g in 1:m) {
    for(j in 0:p) {
      theta_init[((j*K)+1):((j+1)*K), g] <- lasso_coef[j+1, g]
    }
  }
  
  Y_modified <- Y - X%*%lasso_coef
  lin_model <- lm(Y_modified~., data = data.frame(X[, -1]))
  alpha_init <- lin_model$coefficients
  
  result <- add_decomp_r(delta = 1, lambda_1 = 4, lambda_2 = lambda_2, tol_error = 0.1,max_iter = 300,
                       X = X, Y = Y, V = V, Phi = Phi, 
                     theta_0 = theta_init, alpha_0 = alpha_init)
  result
}



stopCluster(cl)
```


$$\int_\Delta\{\hat{\Gamma}(\tau)\}_{jg}d\tau=\sum_{\ell=1}^b\{\hat{\Gamma}(\tau)\}_{jg}\frac{\Delta}{(b-1)}$$

```{r}
h <- tau_seq[2] - tau_seq[1]
alpha_list <- lapply(simulation, FUN = function(x) x$alpha)
theta_list <- lapply(simulation, FUN = function(x) x$theta)
gamma_list <- lapply(theta_list, FUN = function(x) est_gamma(Phi, theta = x))

sum_gamma_list <- lapply(gamma_list, FUN = function(x) x[-1] %>% Reduce("+", .))
int_gamma <- sum_gamma_list %>% lapply(FUN = function(x) x*h)

int_gamma_tidy <- lapply(int_gamma, FUN = function(x) data.frame(col = rep(1:m, each = (p+1)), 
                                                          row = rep(1:(p+1), m),
                                                          value = as.vector(x))) %>%
  `names<-`(value = lamb2_seq) %>%
  bind_rows(.id = "lambda_2") %>% tbl_df %>%
  mutate(lambda_2 = as.numeric(lambda_2), row = as.character(row))

int_gamma_tidy %>%
  mutate(index = paste0("(", col, ",", row, ")")) %>%
  ggplot() +
  geom_line(aes(x = lambda_2, y = value, group = index)) +
  labs(title = "Solution path for sparse matrix", 
       x = expression(lambda[2]), 
       y = expression("integrate"~Gamma~"("~tau~")"))
```















