---
title: "CCLE"
author: "Sohyeon Kim"
date: "10/18/2020"
output: pdf_document
---

# packages
```{r warning = FALSE, message = FALSE}
setwd("C:/Users/Sohyeon Kim/add_decomp_linux")

library(dplyr)
library(stringr)
library(Matrix)
library(data.table)
library(Rcpp)
library(splines)
library(fda)
library(glmnet)
library(foreach)
library(doParallel)

source("https://raw.githubusercontent.com/S0Hye0NKim/add_decomp/master/functions/add_decomp_function.R")
sourceCpp("[KSH]add_decomp_function.cpp")
```




# 0. Data & Screening


## 0-(1) Screening Y

```{r message = FALSE, warning = FALSE}
Y <- fread("ksh_resp_mat.csv")[, -1]
m <- ncol(Y)
trt_nm <- readLines("ksh_trt_nm.txt", encoding = "UTF-8") %>%
  str_split(pattern = ",") %>%
  sapply(FUN = function(x) str_remove_all(x, pattern = "'") %>% str_trim) %>%
  unlist()
trt_nm <- trt_nm[trt_nm != ""]
names(Y) <- trt_nm

Y_sd <- Y[, lapply(.SD, sd)] %>% as.matrix %>% t()
data.frame(Y_sd) %>%
  mutate(group = rownames(.)) %>%
  dplyr::select(group, Y_sd) %>%
  arrange(Y_sd) %>% head(5)

Y <- Y[, -"Panobinostat"] 
m <- ncol(Y)
```

Panobinostat 의 sd = 0.08 -> 제거

## 0-(2) Screening X

### 0-(2)-(1) Standard deviation of X

 * Assumption : Genes with small sd are irrelevant to the drug responses. 

```{r}
X <- fread("ksh_express_mat.csv")
cell_name <- X[[1]]
rownames(X) <- cell_name
X <- X[, -1]

X_sd <- X[, lapply(.SD, FUN = sd)] %>% as.matrix() %>% t()
idx_scr_sd <-  data.frame(X_sd) %>%
  mutate(variable = rownames(.)) %>%
  dplyr::select(variable, X_sd) %>%
  arrange(-X_sd) %>% 
  .[1:10000, ] %>% .$variable

X <- dplyr::select(X, idx_scr_sd)
```


### 0-(2)-(2) Correlation of X and Y

$$\frac{1}{23}\sum_{g\ne11}|\text{cor}(x_j, y_g)|$$

 * Assumption : Genes having low correlations with drugs may not affect the drug responses. 

```{r}
n <- nrow(X)
p <- 100

idx_scr_cor <- cor(X, Y) %>% abs %>%
  apply(MARGIN = 1, FUN = mean) %>%
  data.frame(variable = names(.), cor = .) %>%
  arrange(-cor) %>% first(p) %>% .$variable

X <- dplyr::select(X, idx_scr_cor) %>% 
  apply(MARGIN = 2, FUN = function(x) (x - mean(x))/(sd(x)*sqrt((n-1)/n))) %>%
  cbind(1, .)
colnames(X)[1] <- "intercept"
gene_ex <- colnames(X)
```



```{r}
K <- 2
b <- 15
tau_seq <- seq(from = 0.35, to = 0.65, length.out = b)
idx_tau <- idx_tau <- (tau_seq >= "0.4" & tau_seq <= "0.6")
tau_seq_real <- tau_seq[idx_tau]

knots_seq <- seq(min(tau_seq) - 0.02, max(tau_seq) + 0.02, length.out = K)
Phi <- fda::bsplineS(tau_seq, breaks= knots_seq, norder=2, nderiv=0, returnMatrix=FALSE)

V <- calc_V(as.matrix(X), Phi)
```


```{r}
set.seed(1)
X <- as.matrix(X)
Y <- as.matrix(Y)

 lasso_coef <- matrix(nrow = p+1, ncol = m)
  for(g in 1:m) {
    cv.lasso <- cv.glmnet(x = X[, -1], y = Y[, g], alpha = 1, type.measure = "mae")
    lasso_model <- glmnet(X[, -1], Y[, g], family = "gaussian", alpha = 1, lambda = cv.lasso$lambda.min)
    lasso_coef[, g] <- c(lasso_model$a0, as.vector(lasso_model$beta))
  }

theta_init <- matrix(nrow = (p+1)*K, ncol = m)
  for(g in 1:m) {
    for(j in 0:p) {
      theta_init[((j*K)+1):((j+1)*K), g] <- lasso_coef[j+1, g]
    }
  }
  
  Y_modified <- Y - X%*%lasso_coef
  ridge_coef <- matrix(nrow = p+1, ncol = m)
  for(g in 1:m) {
    cv.ridge <- cv.glmnet(x = X[, -1], y = Y_modified[, g], alpha = 0, type.measure = "mae")
    ridge_model <- glmnet(X[, -1], Y_modified[, g], family = "gaussian", alpha = 0, lambda = cv.ridge$lambda.min)
    ridge_coef[, g] <- c(ridge_model$a0, as.vector(ridge_model$beta))
  }
  alpha_init <- ridge_coef
```



```{r}
library(ggplot2)
data.frame(col = rep(1:m, each = (p+1)), 
           row = rep(1:(p+1), m),
           value = as.vector(lasso_coef)) %>%
  mutate(nonzero = ifelse(abs(value) < 0.1^5, 0, 1) %>% as.character) %>%
  ggplot(aes(x = col, y = -row, fill = nonzero)) +
  geom_tile(color = "grey") +
  scale_fill_manual(values = c("white", "black"), name = "entry", label = c("zero", "non-zero")) + 
  theme_bw() +
  theme(axis.line = element_blank(),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank(), 
    axis.title.x = element_blank(), 
    axis.text.x = element_blank(), 
    axis.ticks.x = element_blank(), 
    axis.title.y = element_blank(), 
    axis.text.y = element_blank(), 
    axis.ticks.y = element_blank()) +
  ggtitle("lasso_coef heatmap") 
```



# 1. Initial value

```{r}
init_val <- add_decomp_r(delta = 1, lambda_1 = 0.01, lambda_2 = 0.001, tol_error = 0.1^5, max_iter = 50,
                         X = X, Y = Y, V = V, Phi = Phi, 
                         theta_0 = theta_init, Z_0 = X%*%alpha_init, tau_seq = tau_seq, weight = FALSE)

```





```{r}
gamma_tau_hat <- est_gamma(Phi[idx_tau, ], init_val$theta)

zero_idx_est <- lapply(gamma_tau_hat, FUN = function(x) which(abs(x) < 0.1^5, arr.ind = TRUE) %>% as_tibble) %>%
    bind_rows (.id = "tau") %>%
    group_by(row, col) %>%
    summarise(zero = n(), .groups = "keep") %>%
    filter(zero == length(gamma_tau_hat))

Neg <- nrow(zero_idx_est)
Pos <- prod(dim(gamma_tau_hat[[1]])) - Neg

data.frame("Positive"=Pos, "Negative" = Neg)


```


# 2. BIC

```{r}
log_lamb1 <- c( seq(0.9, 1.5, length.out = 10))
lamb1_seq <- exp(log_lamb1)

#log_lamb2 <- c(seq(1, 2, length.out = 10))
log_lamb2 <- c(seq(1.2, 3.2, length.out = 10))
lamb2_seq <- exp(log_lamb2)

BIC_table <- list()

for(idx in 1:length(lamb1_seq)) {
  lamb1 <- lamb1_seq[idx]
  cl <- makeCluster(11) #not to overload your computer
  registerDoParallel(cl) # Ready to parallel
  
  temp_BIC <- foreach(lamb2 = lamb2_seq, .noexport = "add_decomp") %dopar% {
    library(dplyr)
    library(splines)
    library(Matrix)
    library(glmnet)
    library(fda)
    
    BIC_simul <- add_decomp_BIC(X, Y, V, Phi, theta_0 = init_val$theta, Z_0 = init_val$Z, tau_seq, tau_seq_real, delta = 1, 
                        lamb1_seq = lamb1, lamb2_seq = lamb2, max_iter = 50)
    BIC_simul$table
  }
  stopCluster(cl)
  BIC_table[[idx]] <- temp_BIC
}
 

BIC_table %>% lapply(FUN = function(x) bind_rows(x)) %>%
  bind_rows() %>%
  mutate(LR_part = r_hat * max(1, m) / (2*n*m),  
         LR = log(n) * LR_part, 
         SP = log(p)*log(log(n)) * SP_part, 
         BIC = log_Q + LR + SP) %>%
  arrange(BIC) %>%
  head(6)

```

```{r}
load("C:/Users/Sohyeon Kim/add_decomp/BIC_table.RData")

BIC_table %>% lapply(FUN = function(x) bind_rows(x)) %>%
  bind_rows() %>%
  mutate(LR_part = r_hat * max(1, m) / (2*n*m),  
         LR = log(n) * LR_part, 
         SP = log(log(n))*log(p) * SP_part, 
         BIC = log_Q + LR + SP) %>%
  arrange(BIC) %>%
  head(6)

```



```{r}
BIC_params <- BIC_table %>% lapply(FUN = function(x) bind_rows(x)) %>%
  bind_rows() %>%
  mutate(LR_part = r_hat * max(1, m) / (2*n*m),  
         LR = log(n) * LR_part, 
         SP = log(p)*log(log(n)) * SP_part, 
         BIC = log_Q + LR + SP) %>%
  mutate_all(.funs = as.numeric) %>% 
  arrange(BIC) %>%
  head(1)
```



```{r}
data <- BIC_table %>% lapply(FUN = function(x) bind_rows(x)) %>%
  bind_rows() %>%
  mutate(LR_part = r_hat * max(1, m) / (2*n*m),  
         LR = log(n) * LR_part, 
         SP = log(p)*log(log(n)) * SP_part, 
         BIC = log_Q + LR + SP) %>%
  mutate_all(.funs = as.numeric) %>%
  arrange(BIC)

```


```{r}
x <- data$lambda_1 %>% unique() %>% sort
y <- data$lambda_2 %>% unique() %>% sort
z <- matrix(0, nrow = length(x), ncol = length(y))

for(i in 1:length(x))
{
  for(j in 1:length(y))
  {

z[i,j] = filter(data, lambda_1 == x[i], lambda_2 == y[j])$BIC
  }
}
```


```{r}
persp3D(x, y, z,theta=30, phi=0, axes=TRUE,scale=2, box=TRUE, nticks=5, 

        ticktype="detailed", xlab="lambda_1", ylab="lambda_2", zlab="BIC", 
        main = "K = 2")
```


 * LR은 log(p)
 
 * SP는 log(log(p)) 로 임의로 선택.


$$\lambda_1=1, \lambda_2=136.1$$

# 3. Proposed Model

```{r}
result <- add_decomp_r(delta = 1, lambda_1 = BIC_params$lambda_1 %>% as.numeric, lambda_2 = BIC_params$lambda_2 %>% as.numeric, tol_error = 0.1^5, max_iter = 50,
                         X = X, Y = Y, V = V, Phi = Phi, 
                         theta_0 = init_val$theta, Z_0 = init_val$Z, tau_seq = tau_seq, weight = TRUE)
```


## Low-rank matrix

```{r}
L_hat <- solve(t(X) %*% X) %*% t(X) %*% result$Z
L_hat %>% rankMatrix
```


```{r}
sing_val <- svd(L_hat)$d
sum(sing_val[1:1])/sum(sing_val)
rankMatrix(result$Z)
sing_val %>% round(2)
```

## Sparse matrix

```{r}

gamma_tau_hat <- est_gamma(Phi[idx_tau, ], result$theta)
```



```{r}
zero_idx_est <- lapply(gamma_tau_hat, FUN = function(x) which(abs(x) < 0.1^5, arr.ind = TRUE) %>% as_tibble) %>%
    bind_rows (.id = "tau") %>%
    group_by(row, col) %>%
    summarise(zero = n(), .groups = "keep") %>%
    filter(zero == length(gamma_tau_hat))

Neg <- nrow(zero_idx_est)
Pos <- prod(dim(gamma_tau_hat[[1]])) - Neg

data.frame("Positive"=Pos, "Negative" = Neg)


```

## heatmap


```{r}
data.frame(col = rep(1:m, each = (p+1)), 
           row = rep(1:(p+1), m),
           value = as.vector(gamma_tau_hat[[5]])) %>%
  mutate(value = ifelse(abs(value) < 0.1^5, 0, value)) %>%
  ggplot(aes(x = col, y = -row, fill = value)) +
  geom_tile(color = "grey") +
  scale_fill_gradient2(low = "red",mid = "white", high = "blue") +
  theme_bw() +
  theme(axis.line = element_blank(),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank(), 
    axis.title.x = element_blank(), 
    axis.text.x = element_blank(), 
    axis.ticks.x = element_blank(), 
    axis.title.y = element_blank(), 
    axis.text.y = element_blank(), 
    axis.ticks.y = element_blank()) +
  ggtitle(expression(Gamma~"("~tau[3]~"=0.5)"))
```

```{r}
data.frame(col = rep(1:m, each = (p)), 
           row = rep(1:p, m),
           value = as.vector(gamma_tau_hat[[5]][-1, ])) %>%
  mutate(value = ifelse(abs(value) < 0.1^5, 0, value)) %>%
  ggplot(aes(x = col, y = -row, fill = value)) +
  geom_tile(color = "grey") +
  scale_fill_gradient2(low = "red",mid = "white", high = "blue") +
  theme_bw() +
  theme(axis.line = element_blank(),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank(), 
    axis.title.x = element_blank(), 
    axis.text.x = element_blank(), 
    axis.ticks.x = element_blank(), 
    axis.title.y = element_blank(), 
    axis.text.y = element_blank(), 
    axis.ticks.y = element_blank()) +
  ggtitle(expression(Gamma~"("~tau[3]~"=0.5)"))
```



```{r}

lapply(gamma_tau_hat, FUN = function(x) data.frame(col = rep(1:m, each = (p+1)),
                                                   row = rep(1:(p+1), m),
                                                   value = as.vector(x))) %>%
  `names<-`(tau_seq_real) %>%
  bind_rows(.id = "tau") %>%
  mutate(is_nonzero = ifelse(abs(value) < 0.1^5, 0, 1)) %>%
  group_by(col, row) %>%
  summarise(is_nonzero = mean(is_nonzero)) %>%
  mutate(is_nonzero = ifelse(is_nonzero == 0, 0, 1) %>% as.character) %>%
  ggplot(aes(x = col, y = -row, fill = is_nonzero)) +
  geom_tile(color = "grey") +
  scale_fill_manual(values = c("white", "black")) + 
  theme_bw() +
  theme(axis.line = element_blank(),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank(), 
    axis.title.x = element_blank(), 
    axis.text.x = element_blank(), 
    axis.ticks.x = element_blank(), 
    axis.title.y = element_blank(), 
    axis.text.y = element_blank(), 
    axis.ticks.y = element_blank()) +
  ggtitle(expression("S("~tau[l]~")"))
```

## smooth function

```{r}
library(tidyr)
idx_nz_est <- lapply(gamma_tau_hat, FUN = function(x) which(abs(x) > 0.1^5, arr.ind = TRUE) %>% as_tibble) %>%
    bind_rows (.id = "tau") %>%
    group_by(row, col) %>%
    summarise(zero = n()) 

gamma_data <- gamma_tau_hat %>%
  lapply(FUN = function(x) x[idx_nz_est$row, idx_nz_est$col] %>% diag %>%
           data.frame(row = idx_nz_est$row, col = idx_nz_est$col, value = . )) %>%
  `names<-`(value = tau_seq_real) %>%
  bind_rows(.id = "tau") %>%
  filter(row == 47, col == 2) %>% 
  unite(col = index, row, col, sep = ",") %>%
  mutate(index = paste0("(", index, ")"), tau = as.numeric(tau))

spline_int <- as.data.frame(spline(gamma_data$tau, gamma_data$value))

ggplot(gamma_data) +
  geom_point(aes(x = tau, y = value), size = 3) +
  geom_line(data = spline_int, aes(x = x, y = y))

```
```{r}
gamma_data <- gamma_tau_hat %>%
  lapply(FUN = function(x) x[idx_nz_est$row, idx_nz_est$col] %>% diag %>%
           data.frame(row = idx_nz_est$row, col = idx_nz_est$col, value = . )) %>%
  `names<-`(value = tau_seq_real) %>%
  bind_rows(.id = "tau") %>%
  filter(col == 15, row != 1) %>%
  unite(col = index, row, col, sep = ",") %>%
  mutate(index = paste0("(", index, ")"), tau = as.numeric(tau))

spline_int <- as.data.frame(spline(gamma_data$tau, gamma_data$value))

ggplot(gamma_data) +
  geom_line(aes(x = tau, y = value, group = index, color = index))
```


```{r}
gamma_tau_hat_full <- est_gamma(Phi, result$theta)


idx_nz_est <- lapply(gamma_tau_hat_full, FUN = function(x) which(abs(x) > 0.1^5, arr.ind = TRUE) %>% as_tibble) %>%
    bind_rows (.id = "tau") %>%
    group_by(row, col) %>%
    summarise(zero = n()) 

gamma_data <- gamma_tau_hat_full %>%
  lapply(FUN = function(x) x[idx_nz_est$row, idx_nz_est$col] %>% diag %>%
           data.frame(row = idx_nz_est$row, col = idx_nz_est$col, value = . )) %>%
  `names<-`(value = tau_seq) %>%
  bind_rows(.id = "tau") %>%
  filter(col == 15, row != 1) %>% 
  unite(col = index, row, col, sep = ",") %>%
  mutate(index = paste0("(", index, ")"), tau = as.numeric(tau))

spline_int <- as.data.frame(spline(gamma_data$tau, gamma_data$value))

ggplot(gamma_data) +
  geom_line(aes(x = tau, y = value, group = index, color = index))

```


# Prediction error


```{r}
PE <- rep(0, 5)

set.seed(1)
sample_idx <- sample(1:5, size = nrow(X), replace = TRUE)

K <- 10
b <- 15
tau_seq <- seq(from = 0.35, to = 0.65, length.out = b)
idx_tau <- idx_tau <- (tau_seq >= "0.4" & tau_seq <= "0.6")
tau_seq_real <- tau_seq[idx_tau]

knots_seq <- seq(min(tau_seq) - 0.02, max(tau_seq) + 0.02, length.out = K)
Phi <- fda::bsplineS(tau_seq, breaks= knots_seq, norder=2, nderiv=0, returnMatrix=FALSE)

for(i in 1:5) {
  X_train <- X[sample_idx != i, ]
  X_test <- X[sample_idx == i, ]
  Y_train <- Y[sample_idx !=i, ]
  Y_test <- Y[sample_idx == i, ]
  
  V <- calc_V(as.matrix(X_train), Phi)
  
  X_train <- as.matrix(X_train)
  Y_train <- as.matrix(Y_train)

 lasso_coef <- matrix(nrow = p+1, ncol = m)
 for(g in 1:m) {
   cv.lasso <- cv.glmnet(x = X_train[, -1], y = Y_train[, g], alpha = 1, type.measure = "mae")
   lasso_model <- glmnet(X_train[, -1], Y_train[, g], family = "gaussian", alpha = 1, lambda = cv.lasso$lambda.min)
   lasso_coef[, g] <- c(lasso_model$a0, as.vector(lasso_model$beta))
 }

 theta_init <- matrix(nrow = (p+1)*K, ncol = m)
 for(g in 1:m) {
   for(j in 0:p) {
     theta_init[((j*K)+1):((j+1)*K), g] <- lasso_coef[j+1, g]
   }
 }
  
 Y_modified <- Y_train - X_train%*%lasso_coef
 ridge_coef <- matrix(nrow = p+1, ncol = m)
 for(g in 1:m) {
   cv.ridge <- cv.glmnet(x = X_train[, -1], y = Y_modified[, g], alpha = 0, type.measure = "mae")
   ridge_model <- glmnet(X_train[, -1], Y_modified[, g], family = "gaussian", alpha = 0, lambda = cv.ridge$lambda.min)
   ridge_coef[, g] <- c(ridge_model$a0, as.vector(ridge_model$beta))
 }
 alpha_init <- ridge_coef
 
 init_val <- add_decomp_r(delta = 1, lambda_1 = 0.025, lambda_2 = 0.001, tol_error = 0.1^5, max_iter = 50,
                         X = X_train, Y = Y_train, V = V, Phi = Phi, 
                         theta_0 = theta_init, Z_0 = X_train%*%alpha_init, tau_seq = tau_seq, weight = FALSE)
  
 log_lamb1 <- c( seq(-7, 7, length.out = 10))
 lamb1_seq <- exp(log_lamb1)

 log_lamb2 <- c(seq(3,10, length.out = 10))
 lamb2_seq <- exp(log_lamb2)

 BIC_table <- list()

 for(idx in 1:length(lamb1_seq)) {
   lamb1 <- lamb1_seq[idx]
   cl <- makeCluster(11) #not to overload your computer
   registerDoParallel(cl) # Ready to parallel
  
   temp_BIC <- foreach(lamb2 = lamb2_seq, .noexport = "add_decomp") %dopar% {
     library(dplyr)
     library(splines)
     library(Matrix)
     library(glmnet)
     library(fda)
    
     BIC_simul <- add_decomp_BIC(X_train, Y_train, V, Phi, theta_0 = init_val$theta, Z_0 = init_val$Z,
                                 tau_seq, tau_seq_real, lamb1_seq = lamb1, lamb2_seq = lamb2, max_iter = 50)
    BIC_simul$table
  }
  stopCluster(cl)
  BIC_table[[idx]] <- temp_BIC
 }
 
 BIC_params <- BIC_table %>% lapply(FUN = function(x) bind_rows(x)) %>%
  bind_rows() %>%
  mutate(LR_part = r_hat * max(1, m) / (2*n*m),  
         LR = log(log(p)) * LR_part, 
         SP = log(p) * SP_part, 
         BIC = log_Q + LR + SP) %>%
  arrange(BIC) %>% 
  head(1)
 
 result <- add_decomp_r(delta = 1, lambda_1 = as.numeric(BIC_params$lambda_1), 
                        lambda_2 = as.numeric(BIC_params$lambda_2),
                        tol_error = 0.1^5, max_iter = 50,
                         X = X_train, Y = Y_train, V = V, Phi = Phi, 
                         theta_0 = init_val$theta, Z_0 = init_val$Z, tau_seq = tau_seq, weight = TRUE)
 
 gamma_tau_hat <- est_gamma(Phi[idx_tau, ], result$theta)
 L_hat <- solve(t(X_train) %*% X_train) %*% t(X_train) %*% result$Z

 Y_hat_test <- mapply(FUN = function(X, L, S) X %*% L + X %*% S, X = list(X_test), L = list(L_hat),
                      S = gamma_tau_hat, SIMPLIFY = FALSE)
 error <- mapply(FUN = function(true, est) true - est, true = list(as.matrix(Y_test)), est = Y_hat_test, 
                 SIMPLIFY = FALSE)
 
 PE[i] <- cal_cl_sum(error, tau_seq_real)
 print(i)
}


```

```{r}
PE <- rep(0, 5)

set.seed(1)
sample_idx <- sample(1:5, size = nrow(X), replace = TRUE)

K <- 10
b <- 15
tau_seq <- seq(from = 0.35, to = 0.65, length.out = b)
idx_tau <- idx_tau <- (tau_seq >= "0.4" & tau_seq <= "0.6")
tau_seq_real <- tau_seq[idx_tau]

knots_seq <- seq(min(tau_seq) - 0.02, max(tau_seq) + 0.02, length.out = K)
Phi <- fda::bsplineS(tau_seq, breaks= knots_seq, norder=2, nderiv=0, returnMatrix=FALSE)

for(i in 1:5) {
  X_train <- X[sample_idx != i, ]
  X_test <- X[sample_idx == i, ]
  Y_train <- Y[sample_idx !=i, ]
  Y_test <- Y[sample_idx == i, ]
  
  X_train <- as.matrix(X_train)
  Y_train <- as.matrix(Y_train)

 ridge_coef <- matrix(nrow = p+1, ncol = m)
  for(g in 1:m) {
    cv.ridge <- cv.glmnet(x = X_train[, -1], y = Y_train[, g], alpha = 0, type.measure = "mae")
    ridge_model <- glmnet(X_train[, -1], Y_train[, g], family = "gaussian", alpha = 0, 
                          lambda = cv.ridge$lambda.min)
    ridge_coef[, g] <- c(ridge_model$a0, as.vector(ridge_model$beta))
  }
 first_init_LR <- ridge_coef
  
 init_val_LR <- LR_model_r(delta = 0.1, lambda = 0.05, tol_error = 0.1^5, max_iter = 50, 
                          X = X_train, Y = Y_train, Z_0 = X_train %*% first_init_LR, 
                          tau_seq = tau_seq, weight = FALSE)
  
 log_lamb <- c( seq(1, 10, length.out = 20))
 lamb_seq <- exp(log_lamb)
 BIC_simul <- LR_model_BIC(X_train, Y_train, Z_0 = init_val_LR$Z, tau_seq, tau_seq_real, lamb_seq, 
                           max_iter = 50, r_X = 1)
  
 BIC_params <- BIC_simul$min_BIC %>%
   arrange(BIC_log_p) %>%
   head(1)
  
 result <- BIC_simul$simulation[[which(lamb_seq == BIC_params$lambda)]]
 
 L_hat <- solve(t(X_train) %*% X_train) %*% t(X_train) %*% result$Z

 Y_hat_test <- X_test %*% L_hat
   
 error <- (Y_test - Y_hat_test) %>% as.matrix
 
 error_list <- list()
 for(l in 1:length(tau_seq_real)) {
   error_list[[l]] <- error
 }
 
 PE[i] <- cal_cl_sum(error_list, tau_seq_real)
 print(i)
}

```

```{r}
PE <- rep(0, 5)

set.seed(1)
sample_idx <- sample(1:5, size = nrow(X), replace = TRUE)

K <- 10
b <- 15
tau_seq <- seq(from = 0.35, to = 0.65, length.out = b)
idx_tau <- idx_tau <- (tau_seq >= "0.4" & tau_seq <= "0.6")
tau_seq_real <- tau_seq[idx_tau]

knots_seq <- seq(min(tau_seq) - 0.02, max(tau_seq) + 0.02, length.out = K)
Phi <- fda::bsplineS(tau_seq, breaks= knots_seq, norder=2, nderiv=0, returnMatrix=FALSE)

for(i in 1:5) {
  X_train <- X[sample_idx != i, ]
  X_test <- X[sample_idx == i, ]
  Y_train <- Y[sample_idx !=i, ]
  Y_test <- Y[sample_idx == i, ]
  
  V <- calc_V(as.matrix(X_train), Phi)
  
  X_train <- as.matrix(X_train)
  Y_train <- as.matrix(Y_train)

 lasso_coef <- matrix(nrow = p+1, ncol = m)
 for(g in 1:m) {
   cv.lasso <- cv.glmnet(x = X_train[, -1], y = Y_train[, g], alpha = 1, type.measure = "mae")
   lasso_model <- glmnet(X_train[, -1], Y_train[, g], family = "gaussian", alpha = 1, lambda = cv.lasso$lambda.min)
   lasso_coef[, g] <- c(lasso_model$a0, as.vector(lasso_model$beta))
 }
  
  first_init_SP <- matrix(nrow = (p+1)*K, ncol = m)
  for(g in 1:m) {
    for(j in 0:p) {
      first_init_SP[((j*K)+1):((j+1)*K), g] <- lasso_coef[j+1, g]
    }
  }

 init_val_SP <- SP_model_r(delta = 1, lambda = 0.001, tol_error = 0.1^5, max_iter = 50, 
                          X = X_train, Y = Y_train, V = V, Phi = Phi, theta_0 = first_init_SP, 
                          tau_seq = tau_seq, weight = FALSE)
 
 lamb_seq <- seq(3, 100, length.out = 20)
 BIC_table <- list()

cl <- makeCluster(20) #not to overload your computer
registerDoParallel(cl) # Ready to parallel
  
BIC_table <- foreach(lambda = lamb_seq, .noexport = "add_decomp") %dopar% {
  library(dplyr)
  library(splines)
  library(Matrix)
  library(Rcpp)
  library(glmnet)
  library(fda)
    
  BIC_simul <- SP_model_BIC(X_train, Y_train, V, Phi, theta_0 = init_val_SP$theta, 
                            tau_seq, tau_seq_real, lamb_seq = lambda, max_iter = 50)
    BIC_simul$min_BIC
  }
stopCluster(cl)
 
 BIC_params <- BIC_table %>%
  bind_rows() %>%
  arrange(BIC_log_p) %>%
  head(1)

 result <- SP_model_r(delta = 1, lambda = as.numeric(BIC_params$lambda), tol_error = 0.1^5, max_iter = 50, 
                          X = X_train, Y = Y_train, V = V, Phi = Phi, theta_0 = init_val_SP$theta, tau_seq = tau_seq, weight = TRUE)
 
 gamma_tau_hat <- est_gamma(Phi[idx_tau, ], result$theta)

 Y_hat_test <- mapply(FUN = function(X, S) X %*% S, X = list(X_test),
                      S = gamma_tau_hat, SIMPLIFY = FALSE)
 error <- mapply(FUN = function(true, est) true - est, true = list(as.matrix(Y_test)), est = Y_hat_test, 
                 SIMPLIFY = FALSE)
 
 PE[i] <- cal_cl_sum(error, tau_seq_real)
 print(i)
}

```






# Low-rank Model

## Initial value


```{r}
X <- as.matrix(X)
Y <- as.matrix(Y)


ridge_coef <- matrix(nrow = p+1, ncol = m)
for(g in 1:m) {
  cv.ridge <- cv.glmnet(x = X[, -1], y = Y[, g], alpha = 0, type.measure = "mae")
  ridge_model <- glmnet(X[, -1], Y[, g], family = "gaussian", alpha = 0, 
                        lambda = cv.ridge$lambda.min)
  ridge_coef[, g] <- c(ridge_model$a0, as.vector(ridge_model$beta))
}
first_init_LR <- ridge_coef
  
init_val_LR <- LR_model_r(delta = 1, lambda = 0.05, tol_error = 0.1^5, max_iter = 50, 
                          X = X, Y = Y, Z_0 = X %*% first_init_LR, tau_seq = tau_seq, weight = FALSE)

log_lamb <- c( seq(1, 10, length.out = 20))
lamb_seq <- exp(log_lamb)

BIC_simul <- LR_model_BIC(X, Y, Z_0 = init_val_LR$Z, tau_seq, tau_seq_real, delta = 1, lamb_seq, max_iter = 50, r_X = 1)
  
BIC_params <- BIC_simul$min_BIC %>%
    arrange(BIC_log_p) %>%
    head(1)
  
result <- BIC_simul$simulation[[which(lamb_seq == BIC_params$lambda)]]
  
```




# Sparse Model

## Initial value

```{r}
X <- as.matrix(X)
Y <- as.matrix(Y)

 lasso_coef <- matrix(nrow = p+1, ncol = m)
  for(g in 1:m) {
    cv.lasso <- cv.glmnet(x = X[, -1], y = Y[, g], alpha = 1, type.measure = "mae")
    lasso_model <- glmnet(X[, -1], Y[, g], family = "gaussian", alpha = 1, lambda = cv.lasso$lambda.min)
    lasso_coef[, g] <- c(lasso_model$a0, as.vector(lasso_model$beta))
  }
  
  first_init_SP <- matrix(nrow = (p+1)*K, ncol = m)
  for(g in 1:m) {
    for(j in 0:p) {
      first_init_SP[((j*K)+1):((j+1)*K), g] <- lasso_coef[j+1, g]
    }
  }
  
  init_val_SP <- SP_model_r(delta = 1, lambda = 0.001, tol_error = 0.1^5, max_iter = 50, 
                          X = X, Y = Y, V = V, Phi = Phi, theta_0 = first_init_SP, tau_seq = tau_seq, weight = FALSE)
```

```{r}
gamma_tau_hat <- est_gamma(Phi[idx_tau, ], init_val_SP$theta)

zero_idx_est <- lapply(gamma_tau_hat, FUN = function(x) which(abs(x) < 0.1^5, arr.ind = TRUE) %>% as_tibble) %>%
    bind_rows (.id = "tau") %>%
    group_by(row, col) %>%
    summarise(zero = n(), .groups = "keep") %>%
    filter(zero == length(gamma_tau_hat))

Neg <- nrow(zero_idx_est)
Pos <- prod(dim(gamma_tau_hat[[1]])) - Neg

data.frame("Positive"=Pos, "Negative" = Neg)


```



```{r}
lamb_seq <- seq(3, 100, length.out = 20)

BIC_table <- list()

cl <- makeCluster(20) #not to overload your computer
registerDoParallel(cl) # Ready to parallel
  
BIC_table <- foreach(lambda = lamb_seq, .noexport = "add_decomp") %dopar% {
  library(dplyr)
  library(splines)
  library(Matrix)
  library(Rcpp)
  library(glmnet)
  library(fda)
    
  BIC_simul <- SP_model_BIC(X, Y, V, Phi, theta_0 = init_val_SP$theta, 
                            tau_seq, tau_seq_real, delta = 1,lamb_seq = lambda, max_iter = 50)
    BIC_simul$min_BIC
  }
stopCluster(cl)
  
BIC_table %>%
  bind_rows() %>%
  arrange(BIC_log_p) %>%
  head(6)



```


```{r}
result <- SP_model_r(delta = 1, lambda = 79.5989, tol_error = 0.1^5, max_iter = 50, 
                          X = X, Y = Y, V = V, Phi = Phi, theta_0 = init_val_SP$theta, tau_seq = tau_seq, weight = TRUE)
```


# Check loss sum

$$\sum_\ell^{b}\sum_{g=1}^m\sum_{i=1}^n\frac{1}{n}\rho_\tau(Y_i^{(g)}-x_i^T[\alpha^{(g)}+\gamma^{(g)}(\tau)])\\=\sum_\ell^{b}\sum_{g=1}^m\sum_{i=1}^n\frac{1}{n}\rho_\tau(e_i^{(\ell)(g)})$$

```{r}
gamma_tau_hat <- est_gamma(Phi[idx_tau, ], result$theta)
L_hat <- solve(t(X_train) %*% X_train) %*% t(X_train) %*% result$Z

Y_hat_test <- mapply(FUN = function(X, L, S) X %*% L + X %*% S, X = list(X_test), L = list(L_hat)
                     , S = gamma_tau_hat, SIMPLIFY = FALSE)
error <- mapply(FUN = function(true, est) true - est, true = list(as.matrix(Y_test)), est = Y_hat_test, SIMPLIFY = FALSE)

cal_cl_sum(error, tau_seq_real)
```




```{r}
cal_cl_sum(result$e, tau_seq)
```

```{r}
est_beta <- lapply(gamma_hat, FUN = function(x) x + result$alpha)
est_e <- lapply(est_beta, FUN = function(x) as.matrix(Y) - X %*% x)

cal_cl_sum(est_e, tau_seq)
  
```



```{r}
Y_list <- list()
for(i in 1:length(tau_seq)) {
  Y_list[[i]] <- as.matrix(Y)
}

cal_cl_sum(Y_list, tau_seq)
```




# various lambda_1

```{r}
lamb_1_seq <- seq(from = 0, to = 0.05, by = 0.01) %>% c(seq(from = 0.1, to = 1, by = 0.1), 2, 4, 6)
simul_lamb1 <- list()

for(idx in 1:length(lamb_1_seq)) {
  simul_lamb1[[idx]] <- add_decomp(delta = 1, lambda_1 = lamb_1_seq[idx], lambda_2 = 1.5,
                                   tol_error = 0.1, max_iter = 300, 
                                   X = as.matrix(X), Y = as.matrix(Y), V = V, Phi = Phi)
  if((idx %% 2) == 1) print(paste0("iter = ", idx))
}
```

```{r}
alpha_hat <- simul_lamb1 %>% lapply(FUN = function(x) x$alpha)

lapply(alpha_hat, FUN = function(x) svd(x) %>% .$d) %>%
  lapply(FUN = function(x) data.frame("ratio" = (sum(x[1])/sum(x)), rank = sum(abs(x) > 0.1^5))) %>%
  `names<-`(value = lamb_1_seq) %>%
  bind_rows(.id = "lambda1") %>%
  ggplot() +
  geom_line(aes(x = lambda1, y = ratio, group = 1)) +
  labs(title = expression("1st singular value / sum of singular values "~lambda[2]~"=1.5 "~delta~"=1, max iter = 300")) +
  xlab(label = expression(lambda[1]))
```


```{r}
simul_lamb1 %>% lapply(FUN = function(x) x$theta %>% est_gamma(Phi = Phi, theta = .) %>% .[[3]]) %>%
  lapply(FUN = function(x) svd(x) %>% .$d) %>%
  lapply(FUN = function(x) data.frame(sigma_1 = x[1], sigma_2 = x[2], sigma_3 = x[3], 
                                      ratio = sum(x[1:3])/sum(x))) %>%
  `names<-`(value = lamb_1_seq) %>%
  bind_rows(.id = "lambda_1")
```


```{r}
alpha_hat %>%
  lapply(FUN = function(x) svd(x) %>% .$d %>% .[1:2] ) %>%
  lapply(FUN = function(x) data.frame(t(x))) %>%
  `names<-`(value = lamb_1_seq) %>%
  bind_rows(.id = "lambda_1") %>%
  `names<-`(value = c("lambda_1", "first", "second")) %>%
  gather(data = ., key = "sing_val", value = value, -lambda_1) %>%
  ggplot() +
  geom_line(aes(x = lambda_1, y = value, group = sing_val, color = sing_val)) +
  facet_wrap(~sing_val, scales = "free_y") +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
```



# various lambda_2

```{r}
lamb_2_seq <- c(seq(from = 0.1, to = 2, by = 0.1), seq(2.5, 5, by = 0.5))
simul_lamb2 <- list()

for(idx in 1:length(lamb_2_seq)) {
  simul_lamb2[[idx]] <- add_decomp(delta = 1, lambda_1 = 1, lambda_2 = lamb_2_seq[idx],
                                   tol_error = 0.1, max_iter = 300, 
                                   X = as.matrix(X), Y = as.matrix(Y), V = V, Phi = Phi)
  if((idx %% 2) == 1) print(paste0("iter = ", idx))
}
```



```{r}
cal_zero <- function(gamma, b) {
  data <- lapply(gamma, FUN = function(x) which(abs(x) < 0.1^5, arr.ind = TRUE) %>% as_tibble) %>%
  `names<-`(value= tau_seq) %>%
  bind_rows(.id = "tau") %>% 
  group_by(row, col) %>%
    summarise(zero = n()) %>%
    filter(zero == b)
  return(nrow(data))
}
```

```{r}
gamma_hat <- simul_lamb2 %>%
  lapply(FUN = function(x) x$theta) %>%
  lapply(FUN = function(x) est_gamma(Phi = Phi, theta = x))

gamma_hat %>%
  lapply(FUN = function(x) cal_zero(gamma = x, b = b) %>% data.frame(zero_count = .)) %>%
  `names<-`(value = lamb_2_seq) %>%
  bind_rows(.id = "lambda_2") %>%
  mutate(ratio = zero_count/((p+1)*m)) %>%
  ggplot() +
  geom_line(aes(x = lambda_2, y = ratio, group = 1)) +
  xlab(label = expression(lambda[2])) +
  labs(title = expression("# of zero entry/total entry"~lambda[1]~"=1, "~delta~"=1, max iter = 300"))
```

```{r}
extr_e <- simul_lamb2 %>%
  lapply(FUN = function(x) x$e) 

cl_sum <- list()
for(i in 1:length(lamb_2_seq)) {
  cl_sum[[i]] <- data.frame(cl_sum = cal_cl_sum(e = extr_e[[i]], tau_seq = tau_seq))
}
```

```{r}
cl_sum %>%
  `names<-`(value = lamb_2_seq) %>%
  bind_rows(.id = "lambda_2") %>%
  ggplot() +
  geom_line(aes(x = lambda_2, y = cl_sum, group = 1))
```


# Two way

```{r}
lamb_1_seq <- seq(from = 0.25, to = 2, by = 0.25)
lamb_2_seq <- seq(from = 0.25, to = 2, by = 0.25)


simul_2_way <- list()
for(idx_1 in 1:length(lamb_1_seq)) {
  simul_2_way[[idx_1]] <- list()
  for(idx_2 in 1:length(lamb_2_seq)) {
    simul_2_way[[idx_1]][[idx_2]] <- add_decomp(delta = 1, lambda_1 = lamb_1_seq[idx_1], 
                                                lambda_2 = lamb_2_seq[idx_2], tol_error = 0.1, 
                                                max_iter = 300, X = as.matrix(X), Y = as.matrix(Y), 
                                                V = V, Phi = Phi)
  }
}
```


```{r}
simul_2_way %>%
  lapply(FUN = function(x) lapply(x, FUN = function(y) cal_cl_sum(e = y$e, tau_seq = tau_seq) %>% data.frame(cl_sum = .))) %>%
  lapply(FUN = function(x) x %>% `names<-`(value= lamb_2_seq) %>% bind_rows(.id = "lambda_2")) %>%
  `names<-`(value = lamb_1_seq) %>%
  bind_rows(.id = "lambda_1") %>%
  ggplot() +
  geom_tile(aes(x = lambda_1, y = lambda_2, fill = cl_sum)) +
  labs(title = "check loss sum when max iter = 300")
```






























